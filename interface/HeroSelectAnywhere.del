import "../main.ostw";
import "HeroSelectConfig.del";
import "../OSTWUtils/OnScreenText.del";
import "../OSTWUtils/Cursor.del";
import "../OSTWUtils/StringSorting.del";

/*
import "../OSTWUtils/Diagnostics.del";
globalvar Diagnostics disp! = new Diagnostics(
    ShowServerLoadAverage:  true, 
    ShowServerLoadPeak:     true,
    ShowTextCount:          true,
    ShowEntityCount:        true
);
//*/
globalvar Hero[] heroesSorted = [];
globalvar Number backdropEffect;
globalvar Number[] textEntities = [];

playervar Boolean isInMenu = false;
playervar Cursor cursor;
playervar Number selectionIndex = -1;
rule: "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒【Hero Select Anywhere by Josbird】▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒" {}
rule: "[HeroSelectAnywhere.del] Open hero select"
Event.OngoingPlayer
if (isInMenu)
{
    DisableHeroHud(EventPlayer());
    DisableGameModeHud(EventPlayer());
    StartCamera(
        Player:         EventPlayer(),
        EyePosition:    camPos,
        LookAtPosition: camPos + camFacing,
    );
    if (!liteMode) selectionIndex = HeroOf() == null ? 
        RandomValueInArray(MappedArray(AllowedHeroes(EventPlayer()), isHeroAllowed(ArrayElement()))) : 
        IndexOfArrayValue(heroesSorted, HeroOf());
    MinWait();
    cursor = new Cursor(-3.75, 3.75, -2, 2);
}
rule: "[HeroSelectAnywhere.del] Close hero select"
Event.OngoingPlayer
if (cursor != null)
if (!isInMenu)
{
    EnableHeroHud(EventPlayer());
    EnableGameModeHud(EventPlayer());
    StopCamera(EventPlayer());
    cursor.close();
    cursor = null;
}

rule: "[HeroSelectAnywhere.del] Teleport out of spawn while in menu"
Event.OngoingPlayer
if(isInMenu)
if(IsInSpawnRoom())
if(HasSpawned())
{
    Teleport(EventPlayer(), camPos - camFacing);
}

rule: "[HeroSelectAnywhere.del] Click logic"
Event.OngoingPlayer
if (isInMenu)
if (IsButtonHeld(EventPlayer(), Button.PrimaryFire))
{
    if (!liteMode) {
        if (cursorInHeroArea() && isHeroAllowed(heroesSorted[cursorHeroIndex(cursor.getX())])) {
            selectionIndex = cursorHeroIndex(cursor.getX());
            playButtonSound();
            WaitUntil(!IsButtonHeld(EventPlayer(), Button.PrimaryFire), 0.25);
            if (IsButtonHeld(EventPlayer(), Button.PrimaryFire)) Abort();
            WaitUntil(IsButtonHeld(EventPlayer(), Button.PrimaryFire), 0.25);
            if (!IsButtonHeld(EventPlayer(), Button.PrimaryFire)) Abort();
            else if (cursorHeroIndex(cursor.getX()) != selectionIndex)
            {
                if (isHeroAllowed(heroesSorted[cursorHeroIndex(cursor.getX())]))
                {
                    selectionIndex = cursorHeroIndex(cursor.getX());
                    playButtonSound();
                }
                Abort();
            }
            else
            {
                switchToHero(heroesSorted[selectionIndex]);
                exitHeroSelect();
            }
        }
        else if (cursorOnCnclBtn(EventPlayer())) {
            exitHeroSelect();
        }
        else if (cursorOnContBtn(EventPlayer())) {
            switchToHero(heroesSorted[selectionIndex]);
            exitHeroSelect();
        }
    }
    else if (cursorInHeroArea() && isHeroAllowed(heroesSorted[cursorHeroIndex(cursor.getX())])) {
        switchToHero(heroesSorted[cursorHeroIndex(cursor.getX())]);
        exitHeroSelect();
    }
}

void switchToHero(Hero h!) "[HeroSelectAnywhere.del] (Subroutine) Switch hero"
{
    ForcePlayerHero(EventPlayer(), h);
    StopForcingHero(EventPlayer());
}

rule: "[HeroSelectAnywhere.del] Deselect disallowed hero"
Event.OngoingPlayer
if (!liteMode)
if (isInMenu)
if (!isHeroAllowed(heroesSorted[selectionIndex]))
{
    selectionIndex = HeroOf() == null ? 
        RandomValueInArray(MappedArray(AllowedHeroes(EventPlayer()), isHeroAllowed(ArrayElement()))) : 
        IndexOfArrayValue(heroesSorted, HeroOf());
}

globalvar Hero[] TankHeroes;
globalvar Hero[] DamageHeroes;
globalvar Hero[] SupportHeroes;
void setupHeroArrays() "[HeroSelectAnywhere.del] (Subroutine) Define hero arrays                              <====== [Change hero roles here]"
{
    #Edit these arrays to move heroes between roles
    TankHeroes = AllTankHeroes();
    DamageHeroes = AllDamageHeroes();
    SupportHeroes = AllSupportHeroes();
}

rule: "[HeroSelectAnywhere.del] Main setup"
{
    setupHeroArrays();
    DisableInspectorRecording();
    heroesSorted += sortAlphabetically(TankHeroes);
    heroesSorted += sortAlphabetically(DamageHeroes);
    heroesSorted += sortAlphabetically(SupportHeroes);
    if (inspectorEnabled) EnableInspectorRecording();
    MinWait();
    CreateEffect(
        VisibleTo:      LocalPlayer(),
        Type:           Effect.Orb,
        Color:          Color.Black,
        Position:       Math.WorldVectorForPositionWithPitch(Vector(0, 0, -0.32), camPos, camFacing, true),
        Reevaluation:   EffectRev.VisibleToPositionAndRadius
    );
    backdropEffect = LastCreatedEntity();
    for (i = 0; CountOf(heroesSorted) / 4; 1)
    {
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         <"<0>  <1>  <2>  <3>", 
                heroString(EvaluateOnce(4 * i + 0)), 
                heroString(EvaluateOnce(4 * i + 1)), 
                heroString(EvaluateOnce(4 * i + 2)), 
                heroString(EvaluateOnce(4 * i + 3))>,
            Position:       screenPos(heroX(4 * i + 1.5), rowY),
            Scale:          (436.3 - 7.25 * CountOf(heroesSorted)) / 100,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleToAndString,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    }
    if (heroDisplay) { CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         <"┌ ─ ┐\n│<0>│\n└ ─ ┘", 
                ArrayContains([Hero.Doomfist, Hero.Ashe], heroesSorted[LocalPlayer().selectionIndex]) ?
                    <" <0>", HeroIconString(heroesSorted[LocalPlayer().selectionIndex])> :
                    <"<0> ", HeroIconString(heroesSorted[LocalPlayer().selectionIndex])>>,
            Position:       screenPos(0, 0),
            Scale:          4,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleToAndString,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    }
    if (roleDividers) {
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "│\n│\n│",
            Position:       screenPos(heroX(-0.5), rowY - 0.01),
            Scale:          2,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "│\n│\n│",
            Position:       screenPos(heroX(CountOf(TankHeroes) - 0.5), rowY - 0.01),
            Scale:          2,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "│\n│\n│",
            Position:       screenPos(heroX(CountOf(TankHeroes) + CountOf(DamageHeroes) - 0.5), rowY - 0.01),
            Scale:          2,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "│\n│\n│",
            Position:       screenPos(heroX(CountOf(heroesSorted) - 0.5), rowY - 0.01),
            Scale:          2,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    }
    if (roleHeaders) {
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         <" 【<0>】TANK", AbilityIconString(Hero.Brigitte, Button.SecondaryFire)>,
            Position:       screenPos(heroX((CountOf(TankHeroes) - 1) / 2), rowY + iconBorderOffset + 0.1),
            Scale:          2,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         <" 【<0>】DAMAGE", IconString(Icon.Skull)>,
            Position:       screenPos(heroX((CountOf(TankHeroes)) +  CountOf(DamageHeroes) / 2 - 0.5), rowY + iconBorderOffset + 0.1),
            Scale:          2,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         <" 【<0>】SUPPORT", AbilityIconString(Hero.Baptiste, Button.Ability1)>,
            Position:       screenPos(heroX((CountOf(heroesSorted)) -  CountOf(SupportHeroes) / 2 - 0.5), rowY + iconBorderOffset + 0.1),
            Scale:          2,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    }

    if (cursorBox) {
        createSelectionBox(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            CenterX:        heroX(cursorHeroIndex(LocalPlayer().cursor.getX())),
            CenterY:        rowY + 0.02,
            Width:          2 * iconBorderOffset,
            Height:         2 * iconBorderOffset,
            TextScale:      selectBoxScale,
            Color:          cursorInHeroArea(LocalPlayer()) &&
                cursorHeroIndex(LocalPlayer().cursor.getX()) != LocalPlayer().selectionIndex &&
                isHeroAllowed(heroesSorted[cursorHeroIndex(LocalPlayer().cursor.getX())], LocalPlayer()) ?
                Color.White : null,
            Reevaluation:   InworldTextRev.VisibleToPositionAndColor,
            Spectators:     Spectators.VisibleNever
        );
    }
    if (selectedBox) {
        createSelectionBox(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            CenterX:        heroX(LocalPlayer().selectionIndex),
            CenterY:        rowY + 0.02,
            Width:          2 * iconBorderOffset,
            Height:         2 * iconBorderOffset,
            TextScale:      selectBoxScale,
            Color:          CustomColor(255, 217, 0, 255),
            Reevaluation:   InworldTextRev.VisibleToAndPosition,
            Spectators:     Spectators.VisibleNever
        );
    }
    if (fancyButtons) {
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "▒▒▒▒▒",
            Position:       screenPos(contBtnX, btnsY),
            Scale:          4,
            TextColor:      cursorOnContBtn(LocalPlayer()) ? CustomColor(207, 124, 0, 255) : CustomColor(255, 153, 0, 255),
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleToAndColor,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "CONTINUE",
            Position:       screenPos(contBtnX, btnsY - 0.01),
            Scale:          3,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "▒▒▒",
            Position:       screenPos(cnclBtnX, btnsY),
            Scale:          4,
            TextColor:      cursorOnCnclBtn(LocalPlayer()) ? CustomColor(0, 125, 197, 255) : CustomColor(0, 162, 255, 255),
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleToAndColor,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "CANCEL",
            Position:       screenPos(cnclBtnX, btnsY),
            Scale:          2.5,
            TextColor:      Color.White,
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    }
    else {
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "CONTINUE",
            Position:       screenPos(contBtnX, btnsY - 0.01),
            Scale:          3,
            TextColor:      CustomColor(255, 153, 0, 255),
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:      visibleIf(LocalPlayer().isInMenu),
            Header:         "CANCEL",
            Position:       screenPos(cnclBtnX, btnsY),
            Scale:          2.5,
            TextColor:      CustomColor(0, 162, 255, 255),
            Clipping:       Clipping.DoNotClip,
            Reevaluation:   InworldTextRev.VisibleTo,
            Spectators:     Spectators.VisibleNever
        );
        ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    }

    CreateInWorldText(
        VisibleTo:      visibleIf(LocalPlayer().cursor != null),
        Header:         "▲",
        Position:       screenPos(LocalPlayer().cursor.getX(), LocalPlayer().cursor.getY()),
        Scale:          3.5,
        TextColor:      Color.White,
        Clipping:       Clipping.DoNotClip,
        Reevaluation:   InworldTextRev.VisibleToAndPosition,
        Spectators:     Spectators.VisibleNever
    );
    ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
}

rule: "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒a" {}

Vector screenPos(Number x, Number y): 
    UpdateEveryFrame(OnScreenText.WorldRender(camPos, camFacing, x, y));
void createSelectionBox(
    in Player | Player[] VisibleTo = EventPlayer(),
    in Number CenterX = 0,
    in Number CenterY = 0,
    in Number Width = 0,
    in Number Height = 0,
    in Number TextScale = 1,
    InworldTextRev Reevaluation = InworldTextRev.VisibleToPositionStringAndColor,
    in Color Color = Color.White,
    Spectators Spectators = Spectators.DefaultVisibility
)
{
    CreateInWorldText(VisibleTo, "┌", screenPos(CenterX - Width / 2, CenterY + Height / 2),
        TextScale, Clipping.DoNotClip, Reevaluation, Color, Spectators);
    ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    CreateInWorldText(VisibleTo, "┐", screenPos(CenterX + Width / 2, CenterY + Height / 2),
        TextScale, Clipping.DoNotClip, Reevaluation, Color, Spectators);
    ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    CreateInWorldText(VisibleTo, "└", screenPos(CenterX - Width / 2, CenterY - Height / 2),
        TextScale, Clipping.DoNotClip, Reevaluation, Color, Spectators);
    ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
    CreateInWorldText(VisibleTo, "┘", screenPos(CenterX + Width / 2, CenterY - Height / 2),
        TextScale, Clipping.DoNotClip, Reevaluation, Color, Spectators);
    ModifyVariable(textEntities, Operation.AppendToArray, LastTextID());
}
Player visibleIf(Boolean condition): 
    condition ? LocalPlayer() : null;
String heroString(Number n): 
    Math.IsInRange(n, 0, CountOf(heroesSorted) - 1) ? isHeroAllowed(heroesSorted[n], LocalPlayer()) ? 
        HeroIconString(heroesSorted[n]) : IconString(Icon.No) : "      ";
Number heroX(Number n):
    rowWidth / -2 + (rowWidth / CountOf(heroesSorted)) * (n + 0.5);
Number cursorHeroIndex(Number x):
    Math.Floor((x / iconBorderOffset + CountOf(heroesSorted)) / 2);
Boolean isHeroAllowed(Hero h, Player p = EventPlayer()): 
    ArrayContains(AllowedHeroes(p), h);
Number iconBorderOffset: rowWidth / CountOf(heroesSorted) / 2;
Boolean cursorInHeroArea(Player p = EventPlayer()):
    Math.IsInRange(p.cursor.getX(), rowWidth / -2, rowWidth / 2) &&
    Math.IsInRange(p.cursor.getY(), rowY - iconBorderOffset * 1.5, rowY + iconBorderOffset * 1.5);
Boolean cursorOnContBtn(Player p = EventPlayer()):
    Math.IsInRange(p.cursor.getX(), contBtnX - contBtnWidth / 2, contBtnX + contBtnWidth / 2) &&
    Math.IsInRange(p.cursor.getY(), btnsY - contBtnHeight / 2, btnsY + contBtnHeight / 2);
Boolean cursorOnCnclBtn(Player p = EventPlayer()):
    Math.IsInRange(p.cursor.getX(), cnclBtnX - cnclBtnWidth / 2, cnclBtnX + cnclBtnWidth / 2) &&
    Math.IsInRange(p.cursor.getY(), btnsY - cnclBtnHeight / 2, btnsY + cnclBtnHeight / 2);
void exitHeroSelect()
{
    isInMenu = null;
    Wait(0.1);
    PlayEffect(
        VisibleTo:      EventPlayer(),
        Type:           PlayEffect.BuffImpactSound,
        Position:       EyePosition() + FacingDirectionOf(),
        Radius:         75
    );
}
void playButtonSound()
{
    PlayEffect(
        VisibleTo:      EventPlayer(),
        Type:           PlayEffect.BuffImpactSound,
        Position:       camPos + camFacing,
        Radius:         75
    );
}

void destroyMenu()
{
    DestroyEffect(backdropEffect);
    foreach (Number text in textEntities) { DestroyInWorldText(text); }
}