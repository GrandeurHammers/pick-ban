import "customGameSettings.lobby";

globalvar define numProtects = WorkshopSettingInteger("Protect/Ban", "Hero Protects", 1, 0, 15, 2);
globalvar define numBans = WorkshopSettingInteger("Protect/Ban", "Hero Bans", 1, 0, 15, 0);
globalvar define timePerPhase = WorkshopSettingInteger("Protect/Ban", "Time Limit Per Phase", 20, 5, 120, 9.9);
globalvar define maxProtectVotes = WorkshopSettingInteger("Protect/Ban", "Protect Votes Per Player", 2, 1, 15, 3);
globalvar define maxBanVotes = WorkshopSettingInteger("Protect/Ban", "Ban Votes Per Player", 2, 1, 15, 1);
globalvar define globalCursors = WorkshopSettingToggle("Menu Options", "See All Cursors", true, 0);
globalvar define losingTeam = WorkshopSettingCombo("Protect/Ban", "Extra Bans Team", 0, ["None", "Team 1", "Team 2"], 10);
globalvar define losingTeamBans = WorkshopSettingInteger("Protect/Ban", "Extra Bans", 1, 1, 15, 11);
globalvar define losingTeamBanVotes = WorkshopSettingInteger("Protect/Ban", "Extra Ban Votes Per Player", 2, 1, 15, 12);
globalvar define progressOnMaxVotes = WorkshopSettingToggle("Protect/Ban", "Skip Timer When All Players Have Max Selections", true, 100);
globalvar define allowRepeatHeroVotes = WorkshopSettingToggle("Protect/Ban", "Allow Repeat Votes For Same Hero", false, 20);
// END CUSTOMIZATION
globalvar Phase currentPhase;
globalvar define isPhaseActive;
globalvar define selectTimeRemaining;
globalvar define heroPool = AllHeroes();
globalvar define protectedHeroes = [];
globalvar define bannedHeroes = [];
globalvar define resultsTally;
globalvar define selectedHeroes;
globalvar define textsToDestroy;
globalvar define[] waitingText;
globalvar define i 127;

playervar define selectionList;
playervar define textToDestroy;

define MaxVotesForPhase: [maxBanVotes, maxProtectVotes, losingTeamBanVotes][IndexOfArrayValue([Phase.Ban, Phase.Protect, Phase.ExtraBan], currentPhase)];

enum Phase {
    Waiting,
    Protect,
    Ban,
    ExtraBan,
    Normal
}

rule: "Pre-game setup"
{
    if (!WorkshopSettingToggle("Debug", "Inspector Enabled", false, 0)) {
        DisableInspectorRecording();
    }
    # Convert integer selection of Extras team to team constants
    losingTeam = [null, Team.Team1, Team.Team2][losingTeam];
}

rule: "Create Waiting for Players HUD"
{
    CreateInWorldText(
        Header: @"Waiting On Players",
        TextColor: Color.Yellow,
        Position: ScreenToWorld(menuPos, menuFacing, 0, 0),
        Scale: 4,
        Clipping: Clipping.DoNotClip,
        Reevaluation: HudTextRev.VisibleTo,
        Spectators: Spectators.VisibleNever
    );
    ModifyVariable(waitingText, Operation.AppendToArray, LastTextID());
    CreateInWorldText(
        Header: <@"<0> / <1> Players Selected Hero", CountOf(FilteredArray(AllPlayers(), HasSpawned(ArrayElement()))), NumberOfPlayers()>,
        TextColor: Color.White,
        Position: ScreenToWorld(menuPos, menuFacing, 0, -0.25),
        Scale: 2,
        Clipping: Clipping.DoNotClip,
        Reevaluation: HudTextRev.VisibleToAndString,
        Spectators: Spectators.VisibleNever
    );
    ModifyVariable(waitingText, Operation.AppendToArray, LastTextID());
    # Spectator version
    CreateHudText(
        VisibleTo: null,
        Header: <@"Waiting On Players: <0> / <1> Spawned", CountOf(FilteredArray(AllPlayers(), HasSpawned(ArrayElement()))), NumberOfPlayers()>,
        TextColor: Color.Yellow,
        Location: Location.Top,
        SortOrder: 1,
        HeaderColor: Color.Yellow,
        Reevaluation: HudTextRev.String,
        Spectators: Spectators.VisibleAlways
    );
    ModifyVariable(specTexts, Operation.AppendToArray, LastTextID());
}

globalvar define[] specTexts;

rule: "Create spectator HUD"
if (selectTimeRemaining > 0)
{
    CreateHudText(
        VisibleTo: null,
        Header: <"<0> Phase Voting Leaderboard", currentPhase == Phase.Protect ? @"Protect" :
                                                    currentPhase == Phase.Ban ? @"Ban" :
                                                    currentPhase == Phase.ExtraBan ? @"Bonus Ban" : "">,
        HeaderColor: Color.Yellow,
        Location: Location.Right,
        SortOrder: 1,
        Reevaluation: HudTextRev.String,
        Spectators: Spectators.VisibleAlways
    );
    ModifyVariable(specTexts, Operation.AppendToArray, LastTextID());
    for (i = 0; 5; 1) {
        CreateHudText(
            VisibleTo: null,
            Header: <"<0> | <1> Votes", HeroIconString(SortedArray(AllHeroes(), -1*resultsTally[CurrentArrayIndex()])[EvaluateOnce(i)]), SortedArray(resultsTally, -1*ArrayElement())[EvaluateOnce(i)]>,
            Location: Location.Right,
            HeaderColor: Color.White,
            SortOrder: EvaluateOnce(i) + 2,
            Reevaluation: HudTextRev.String,
            Spectators: Spectators.VisibleAlways
        );
        ModifyVariable(specTexts, Operation.AppendToArray, LastTextID());
    }
    WaitUntil(selectTimeRemaining == 0, selectTimeRemaining + 10);
    foreach(define t in specTexts) DestroyHudText(t);
}

rule: "Global setup"
if (IsWaitingForPlayers() == false)
if (currentPhase == Phase.Waiting)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())) && CountOf(AllPlayers()) > 0)
{
    Wait(3);
    foreach(define text in waitingText) DestroyInWorldText(text);
    foreach(define text in specTexts) DestroyHudText(text);
    BigMessage(AllPlayers(), <"<0><1>", @"Starting", @"...">);
    Wait(3);
    # Set the current phase
    if (numProtects > 0) {
        currentPhase = Phase.Protect;
    } else if (numBans > 0) {
        currentPhase = Phase.Ban;
    } else if (losingTeam != null) {
        currentPhase = Phase.ExtraBan;
    } else {
        currentPhase = Phase.Normal;
    }
    AbortIf(currentPhase == Phase.Normal);
    async RefreshCursorVis();
    # Prevent normal game stuff from interfering
    DisableAnnouncer();
    DisableMessages(AllPlayers());
    # Create some universal HUDs
    CreateProgressBarHudText(
        VisibleTo: selectTimeRemaining > 0 ? AllPlayers() : null,
        Value: selectTimeRemaining / timePerPhase * 100,
        Text: <@"Time Remaining: <0> sec", RoundToInteger(selectTimeRemaining, Rounding.Up)>,
        Location: Location.Top,
        SortOrder: 15,
        ProgressBarColor: CustomColor(
            Red:   255,
            Green: Min(255, 255*(selectTimeRemaining*2/timePerPhase)^2),
            Blue:  Min(255, 255*(selectTimeRemaining*2/timePerPhase)^2),
            Alpha: 255
        ),
        TextColor: Color.White,
        Reevaluation: ProgressBarEvaluation.VisibleToValuesAndColor
    );
    textsToDestroy = [LastTextID()];
}

rule: "Refresh cursor to appear above clear selection"
if (selectTimeRemaining > 0)
{
    RefreshCursorVis();
}

rule: "For protect and ban phases, skip Assembling Heroes and freeze time"
if (IsAssemblingHeroes())
if (currentPhase != Phase.Normal)
{
    DisableAnnouncer();
    DisableMessages(AllPlayers());
    MinWait();
    while (Not(IsGameInProgress())) {
        SetMatchTime(0);
        MinWait();
    }
    PauseMatchTime();
    WaitUntil(currentPhase == Phase.Normal, 1000000);
    UnpauseMatchTime();
}

rule: "Player setup"
Event.OngoingPlayer
{
    # Initialize player selection list
    EventPlayer().selectionList = [];
    # If a hero pool has been decided, restrict the player to that pool
    if (currentPhase == Phase.Normal) {
        SetAllowedHeroes(EventPlayer(), heroPool);
        return;
    }
    textToDestroy = [];
    for (i = 0; Max(maxProtectVotes, Max(maxBanVotes, losingTeam != null ? losingTeamBanVotes : 0)) / 4; 1) {
        CreateHudText(
            VisibleTo:      CountOf(selectionList) > 4*EvaluateOnce(i) ? EventPlayer() : null,
            Header:         <"<0><1><2><3>",
                                HeroIconString(selectionList[4*EvaluateOnce(i)+0]),
                                HeroIconString(selectionList[4*EvaluateOnce(i)+1]),
                                HeroIconString(selectionList[4*EvaluateOnce(i)+2]),
                                HeroIconString(selectionList[4*EvaluateOnce(i)+3])
                            >,
            Location: Location.Right,
            SortOrder: -99 + 4*i,
            Reevaluation: HudTextRev.VisibleToAndString,
            Spectators: Spectators.VisibleNever
        );
        ModifyVariable(textToDestroy, Operation.AppendToArray, LastTextID());
    }
    CreateHudText(
        VisibleTo: selectTimeRemaining > 0 ? EventPlayer() : null,
        Header: <"<0> <1>:<2>", @"Selected", @"Heroes",
                    selectTimeRemaining > 0 && (currentPhase != Phase.ExtraBan || TeamOf() == losingTeam) ? <" <0>/<1>", CountOf(selectionList), MaxVotesForPhase> : "">,
        Location: Location.Right,
        SortOrder: -100,
        HeaderColor: Color.Aqua,
        Reevaluation: HudTextRev.VisibleToAndString,
        Spectators: Spectators.VisibleNever
    );
    ModifyVariable(textToDestroy, Operation.AppendToArray, LastTextID());
}

rule: "Handle conditional player enable/disables"
Event.OngoingPlayer
if (currentPhase != Phase.Normal)
if (HasSpawned())
{
    ForceThrottle(EventPlayer(), 0, 0, 0, 0, 0, 0);
    SetInvisible(InvisibleTo: InvisibleTo.All);
    SetGravity(EventPlayer(), 0);
    DisableMovementCollisionWithEnvironment(IncludeFloors: false);
    DisableMovementCollisionWithPlayers();
    DisableMessages();
    EventPlayer().isInMenu = true;
    DisableGameModeHud();
    DisableGameModeInworldUI();
    DisallowButtons(allButtons);

    WaitUntil(currentPhase == Phase.Normal && IsAssemblingHeroes(), 1000000);
    EventPlayer().isInMenu = false;
    Wait(0.25);
    
    StopForcingThrottle(EventPlayer());
    SetInvisible(InvisibleTo: InvisibleTo.None);
    SetGravity(EventPlayer(), 100);
    EnableMovementCollisionWithEnvironment();
    EnableMovementCollisionWithPlayers();
    EnableMessages();
    EnableGameModeHud();
    EnableGameModeInworldUI();
    AllowButtons(allButtons);

    for (define j = 0; CountOf(textToDestroy); 1) {
        DestroyHudText(textToDestroy[j]);
    }
}

disabled rule: "====PROTECT PHASE====" {}

rule: "Start of protect phase setup"
if (currentPhase == Phase.Protect)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    BigMessage(AllPlayers(), <@"Started Protect Phase">);
    PlayEffect(AllPlayers(), PlayEffect.BuffImpactSound, Color.White, menuPos, 50);
    # Clear results tally
    resultsTally = [];
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of protect phase"
if (currentPhase == Phase.Protect)
if (isPhaseActive)
if ((progressOnMaxVotes && IsTrueForAll(AllPlayers(), CountOf(ArrayElement().selectionList) == maxProtectVotes))
    || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), <@"Protect Phase Finished">);
    PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, Color.White, menuPos, 50);
    selectedHeroes = [];
    //Select the numProtects most voted heroes
    while (CountOf(selectedHeroes) < numProtects) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, numProtects - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove protected heroes from the hero pool (for banning purposes)
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Remember which heroes got protected so we can add them back to the hero pool after banning
    protectedHeroes = selectedHeroes;
    #Reset the timer
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    #Reset player selection lists
    AllPlayers().selectionList = [];
    # Show which heroes have been protected
    CreateHudText(
        VisibleTo: AllPlayers(),
        Header: @"Protect:",
        Location: Location.Left,
        SortOrder: 0,
        HeaderColor: Color.Yellow,
        Reevaluation: HudTextRev.VisibleTo
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    for (i = 0; CountOf(protectedHeroes) / 4; 1) {
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: <"<0><1><2><3>",
                EvaluateOnce(HeroIconString(protectedHeroes[4*i])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+1])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+2])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+3]))
            >,
            Location: Location.Left,
            SortOrder: i+1,
            HeaderColor: Color.White,
            Reevaluation: HudTextRev.VisibleTo
        );
        ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    }
    Wait(5);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = numBans > 0 ? Phase.Ban : losingTeam != null ? Phase.ExtraBan : Phase.Normal;
}

disabled rule: "====BAN PHASE====" {}

rule: "Start of ban phase setup"
if (currentPhase == Phase.Ban)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    BigMessage(AllPlayers(), <@"Started Ban Phase">);
    PlayEffect(AllPlayers(), PlayEffect.BuffImpactSound, Color.White, menuPos, 50);
    # Clear results tally
    resultsTally = [];
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of ban phase"
if (currentPhase == Phase.Ban)
if (isPhaseActive)
if ((progressOnMaxVotes && IsTrueForAll(AllPlayers(), CountOf(ArrayElement().selectionList) == maxBanVotes)) || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), <@"Finished Ban Phase">);
    PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, Color.White, menuPos, 50);
    selectedHeroes = [];
    //Select the numBans most voted heroes
    while (CountOf(selectedHeroes) < numBans) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, numBans - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove banned heroes from the hero pool
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Remember which heroes got banned
    bannedHeroes = selectedHeroes;
    #Reset the timer
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    #Reset player selection lists
    AllPlayers().selectionList = [];
    # Spacer HUD
    CreateHudText(
        VisibleTo: AllPlayers(),
        Text: " \n",
        Location: Location.Left,
        SortOrder: numProtects+0.5,
        Reevaluation: HudTextRev.VisibleTo
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    CreateHudText(
        VisibleTo: AllPlayers(),
        Header: @"Ban:",
        Location: Location.Left,
        SortOrder: numProtects+1,
        HeaderColor: Color.Red,
        Reevaluation: HudTextRev.VisibleTo
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    for (i = 0; CountOf(bannedHeroes) / 4; 1) {
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: <"<0><1><2><3>",
                HeroIconString(bannedHeroes[EvaluateOnce(4*i+0)]),
                HeroIconString(bannedHeroes[EvaluateOnce(4*i+1)]),
                HeroIconString(bannedHeroes[EvaluateOnce(4*i+2)]),
                HeroIconString(bannedHeroes[EvaluateOnce(4*i+3)])
            >,
            Location: Location.Left,
            SortOrder: numProtects+i+2,
            HeaderColor: Color.White,
            Reevaluation: HudTextRev.VisibleToAndString
        );
        ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    }
    Wait(5);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = losingTeam != null ? Phase.ExtraBan : Phase.Normal;
}

disabled rule: "====EXTRA BAN PHASE====" {}

rule: "Start of extra bans phase setup"
if (currentPhase == Phase.ExtraBan)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    BigMessage(AllPlayers(), <@"Started Bonus Ban Phase">);
    PlayEffect(AllPlayers(), PlayEffect.BuffImpactSound, Color.White, menuPos, 50);
    # Clear results tally
    resultsTally = [];
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of extra bans phase"
if (currentPhase == Phase.ExtraBan)
if (isPhaseActive)
if ((progressOnMaxVotes && IsTrueForAll(AllPlayers(losingTeam), CountOf(ArrayElement().selectionList) == losingTeamBanVotes))
    || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), <@"Bonus Ban Phase Finished">);
    PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, Color.White, menuPos, 50);
    selectedHeroes = [];
    while (CountOf(selectedHeroes) < losingTeamBans) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, losingTeamBans - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove banned heroes from the hero pool
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Add banned heroes to the existing bans
    ModifyVariable(bannedHeroes, Operation.AppendToArray, selectedHeroes);
    for (i = CountOf(bannedHeroes) - CountOf(selectedHeroes); CountOf(bannedHeroes); 1) {
        if (i % 4 != 0) {
            continue;
        }
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: <"<0><1><2><3>",
                HeroIconString(bannedHeroes[EvaluateOnce(4*i+0)]),
                HeroIconString(bannedHeroes[EvaluateOnce(4*i+1)]),
                HeroIconString(bannedHeroes[EvaluateOnce(4*i+2)]),
                HeroIconString(bannedHeroes[EvaluateOnce(4*i+3)])
            >,
            Location: Location.Left,
            SortOrder: numProtects+i+2,
            HeaderColor: Color.White,
            Reevaluation: HudTextRev.VisibleToAndString
        );
        ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    }
    Wait(5);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = Phase.Normal;
}

disabled rule: "====NORMAL GAMEPLAY====" {}

rule: "Prepare to enter normal gameplay"
if (currentPhase == Phase.Normal)
{
    # Add protected heroes back to the hero pool
    ModifyVariable(heroPool, Operation.AppendToArray, protectedHeroes);
    # Only allow the heroes in the pool
    SetAllowedHeroes(AllPlayers(), heroPool);
    # Disable in-game announcer during reset to Assemble Heroes
    DisableAnnouncer();
    # Disable messages during reset to Assemble Heroes
    DisableMessages(AllPlayers());
    Wait(0.25);
    // Skip to game in progress momentarily to allow Assemble Heroes to work
    while (!IsGameInProgress()) {
        SetMatchTime(0);
        MinWait();
    }
    GoToAssembleHeroes();
    Wait(0.1);
    EnableAnnouncer();
    Wait(3);
     # Clean up the menu
    destroyMenu();
    async CleanupTexts();
    EnableMessages(AllPlayers());
}

void CleanupTexts() "[SUB] Clean up protect/ban texts" {
    WaitUntil(IsGameInProgress(), 9999);
    for (i = 0; CountOf(textsToDestroy); 1) {
        DestroyHudText(textsToDestroy[i]);
    }
    textsToDestroy = [];
}

import "PlayerInterface.del";
