globalvar define numProtects;
globalvar define numBans;
globalvar define timePerPhase;
// END CUSTOMIZATION
globalvar Phase currentPhase;
globalvar define isPhaseActive;
globalvar define selectTimeRemaining;
globalvar define heroPool;
globalvar define protectedHeroes;
globalvar define bannedHeroes;
globalvar define resultsTally;
globalvar define selectedHeroes;
globalvar define textsToDestroy;
globalvar define i 127;

playervar define selectionList;

enum Phase {
    Protect = 1,
    Ban = 2,
    Normal = 3
} 

rule: "Customization Workshop Settings" 
{
    numProtects = WorkshopSettingInteger("Pick/Ban", "Hero Protects", 1, 0, 15, 1);
    numBans = WorkshopSettingInteger("Pick/Ban", "Hero Bans", 1, 0, 15, 0);
    timePerPhase = WorkshopSettingInteger("Pick/Ban", "Time Limit Per Phase", 20, 5, 120, 2);
}

void TallyVotes() "[SUB] Count up number of votes for each hero"
{
    resultsTally = [];
    for (i = 0; CountOf(AllHeroes()); 1) {
        resultsTally[i] = CountOf(FilteredArray(AllPlayers(), ArrayContains(ArrayElement().selectionList, AllHeroes()[i])));
    }
}

rule: "Global setup"
if (IsWaitingForPlayers() == false)
{
    # Initialize the hero pool
    heroPool = AllHeroes();
    # Set the current phase
    if (numProtects > 0) {
        currentPhase = Phase.Protect;
    } else if (numBans > 0) {
        currentPhase = Phase.Ban;
    } else {
        currentPhase = Phase.Normal;
    }
    # Prevent normal game stuff from interfering
    DisableAnnouncer();
    DisableMessages(AllPlayers());
    // TODO: Create HUDs
    CreateProgressBarHudText(selectTimeRemaining > 0 ? AllPlayers() : null, selectTimeRemaining / timePerPhase * 100, <@"<0> Phase", currentPhase == Phase.Protect ? @"Protect" : @"Ban">, Location.Top, 5, Color.White, Color.White, ProgressBarEvaluation.VisibleToAndValues, Spectators.DefaultVisibility);
    textsToDestroy = [LastTextID()];
}

rule: "For protect and ban phases, skip Assembling Heroes and freeze time"
if (IsAssemblingHeroes())
if (currentPhase != Phase.Normal)
{
    SetMatchTime(0);
    WaitUntil(Not(IsAssemblingHeroes()), 1000000);
    PauseMatchTime();
    WaitUntil(currentPhase == Phase.Normal, 1000000);
    UnpauseMatchTime();
}

rule: "Player setup"
Event.OngoingPlayer
{
    # Initialize player selection list
    EventPlayer().selectionList = [];
    # If a hero pool has been decided, restrict the player to that pool
    if (currentPhase == Phase.Normal) {
        SetAllowedHeroes(EventPlayer(), heroPool);
    # Otherwise, if we're doing protect/ban phases, disable normal game stuff to prevent issues
    } else {
        DisableMessages();
    }
}

rule: "Prevent player motion during Protect/Ban phases"
Event.OngoingPlayer
if (currentPhase == Phase.Protect || currentPhase == Phase.Ban)
{
    StartForcingPlayerPosition(EventPlayer(), PositionOf(EventPlayer()), false);
    WaitUntil(currentPhase != Phase.Protect && currentPhase != Phase.Ban, 1000000);
    StopForcingPlayerPosition(EventPlayer());
}

disabled rule: "====PROTECT PHASE====" {}

rule: "Start of protect phase setup"
if (currentPhase == Phase.Protect)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    BigMessage(AllPlayers(), <@"Started Protect Phase">);
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of protect phase"
if (currentPhase == Phase.Protect)
if (isPhaseActive)
if (IsTrueForAll(AllPlayers(), CountOf(ArrayElement().selectionList) == numProtects) || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), <@"Protect Phase Finished">);
    #Tally votes for heroes to protect
    TallyVotes();
    selectedHeroes = [];
    //Select the numProtects most voted heroes
    while (CountOf(selectedHeroes) < numProtects) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, numProtects - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove protected heroes from the hero pool (for banning purposes)
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Remember which heroes got protected so we can add them back to the hero pool after banning
    protectedHeroes = selectedHeroes;
    #Reset the timer
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    #Reset player selection lists
    AllPlayers().selectionList = [];
    // TODO: Communicate which heroes got protected
    CreateHudText(
        VisibleTo: AllPlayers(),
        Header: @"Protect:",
        Location: Location.Left,
        SortOrder: 0,
        HeaderColor: Color.Yellow,
        Reevaluation: HudTextRev.VisibleTo
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    for (i = 0; CountOf(protectedHeroes) / 4; 1) {
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: <"<0><1><2><3>",
                EvaluateOnce(HeroIconString(protectedHeroes[4*i])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+1])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+2])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+3]))
            >,
            Location: Location.Left,
            SortOrder: i+1,
            HeaderColor: Color.White,
            Reevaluation: HudTextRev.VisibleTo
        );
        ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    }
    Wait(5);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = numBans > 0 ? Phase.Ban : Phase.Normal;
}

disabled rule: "====BAN PHASE====" {}

rule: "Start of ban phase setup"
if (currentPhase == Phase.Ban)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    BigMessage(AllPlayers(), <@"Started Ban Phase">);
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of ban phase"
if (currentPhase == Phase.Ban)
if (isPhaseActive)
if (IsTrueForAll(AllPlayers(), CountOf(ArrayElement().selectionList) == numBans) || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), <@"Finished Ban Phase">);
    #Tally votes for heroes to protect
    TallyVotes();
    selectedHeroes = [];
    //Select the numBans most voted heroes
    while (CountOf(selectedHeroes) < numBans) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, numBans - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove banned heroes from the hero pool
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Remember which heroes got banned
    bannedHeroes = selectedHeroes;
    #Reset the timer
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    #Reset player selection lists
    AllPlayers().selectionList = [];
    // TODO: Communicate which heroes got banned
    CreateHudText(
        VisibleTo: AllPlayers(),
        Header: @"Ban:",
        Location: Location.Left,
        SortOrder: numProtects,
        HeaderColor: Color.Red,
        Reevaluation: HudTextRev.VisibleTo
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    for (i = 0; CountOf(bannedHeroes) / 4; 1) {
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: <"<0><1><2><3>",
                EvaluateOnce(HeroIconString(bannedHeroes[4*i])),
                EvaluateOnce(HeroIconString(bannedHeroes[4*i+1])),
                EvaluateOnce(HeroIconString(bannedHeroes[4*i+2])),
                EvaluateOnce(HeroIconString(bannedHeroes[4*i+3]))
            >,
            Location: Location.Left,
            SortOrder: numProtects+i+1,
            HeaderColor: Color.White,
            Reevaluation: HudTextRev.VisibleTo
        );
        ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    }
    Wait(5);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = Phase.Normal;
}

disabled rule: "====NORMAL GAMEPLAY====" {}

rule: "Prepare to enter normal gameplay"
if (currentPhase == Phase.Normal)
{
    # Add protected heroes back to the hero pool
    ModifyVariable(heroPool, Operation.AppendToArray, protectedHeroes);
    # Only allow the heroes in the pool
    SetAllowedHeroes(AllPlayers(), heroPool);
    # Disable in-game announcer during reset to Assemble Heroes
    DisableAnnouncer();
    // Skip to game in progress momentarily to allow Assemble Heroes to work
    while (!IsGameInProgress()) {
        SetMatchTime(0);
        MinWait();
    }
    Wait(0.25);
    EnableAnnouncer();
    EnableMessages(AllPlayers());
    GoToAssembleHeroes();
    WaitUntil(IsGameInProgress(), 9999);
    for (i = 0; CountOf(textsToDestroy); 1) {
        DestroyHudText(textsToDestroy[i]);
    }
    textsToDestroy = [];
}

disabled rule: "DEBUG: Add current hero to selectionList"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.Interact))
if (currentPhase == Phase.Protect || currentPhase == Phase.Ban)
{
    ModifyVariable(EventPlayer().selectionList, Operation.AppendToArray, HeroOf(EventPlayer()));
    MinWait();
    SmallMessage(EventPlayer(), <"Selected Hero: <0>", HeroIconString(LastOf(EventPlayer().selectionList))>);
}
