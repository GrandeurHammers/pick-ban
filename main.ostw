globalvar define numProtects;
globalvar define numBans;
globalvar define timePerPhase;
// END CUSTOMIZATION
globalvar Phase currentPhase;
globalvar define isPhaseActive;
globalvar define selectTimeRemaining;
globalvar define heroPool;
globalvar define protectedHeroes;
globalvar define bannedHeroes;
globalvar define resultsTally;
globalvar define selectedHeroes;
globalvar define i 127;

playervar define selectionList;

enum Phase {
    Protect = 1,
    Ban = 2,
    Normal = 3
} 

rule: "Customization Workshop Settings" 
{
    numProtects = WorkshopSettingInteger("Pick/Ban", "Hero Protects", 1, 0, 15, 1);
    numBans = WorkshopSettingInteger("Pick/Ban", "Hero Bans", 1, 0, 15, 0);
    timePerPhase = WorkshopSettingInteger("Pick/Ban", "Time Limit Per Phase", 20, 5, 120, 2);
}

void TallyVotes() "[SUB] Count up number of votes for each hero"
{
    resultsTally = [];
    for (i = 0; CountOf(AllHeroes()); 1) {
        resultsTally[i] = CountOf(FilteredArray(AllPlayers(), ArrayContains(ArrayElement().selectionList, AllHeroes()[i])));
    }
}

rule: "Global setup"
if (IsWaitingForPlayers() == false)
{
    # Initialize the hero pool
    heroPool = AllHeroes();
    # Set the current phase
    if (numProtects > 0) {
        currentPhase = Phase.Protect;
    } else if (numBans > 0) {
        currentPhase = Phase.Ban;
    } else {
        currentPhase = Phase.Normal;
    }
    // TODO: Create HUDs
}

rule: "For protect and ban phases, skip Assembling Heroes and freeze time"
if (IsAssemblingHeroes())
if (currentPhase != Phase.Normal)
{
    SetMatchTime(0);
    WaitUntil(Not(IsAssemblingHeroes()), 1000000);
    PauseMatchTime();
    WaitUntil(currentPhase == Phase.Normal, 1000000);
    UnpauseMatchTime();
}

rule: "Player setup"
Event.OngoingPlayer
{
    # Initialize player selection list
    EventPlayer().selectionList = [];
    # If a hero pool has been decided, restrict the player to that pool
    if (currentPhase == Phase.Normal) {
        SetAllowedHeroes(EventPlayer(), heroPool);
    }
}

rule: "Prevent player motion during Protect/Ban phases"
Event.OngoingPlayer
if (currentPhase == Phase.Protect || currentPhase == Phase.Ban)
{
    StartForcingPlayerPosition(EventPlayer(), PositionOf(EventPlayer()), false);
    WaitUntil(currentPhase != Phase.Protect && currentPhase != Phase.Ban, 1000000);
    StopForcingPlayerPosition(EventPlayer());
}

disabled rule: "====PROTECT PHASE====" {}

rule: "Start of protect phase setup"
if (currentPhase == Phase.Protect)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    BigMessage(AllPlayers(), "Started Protect Phase");
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of protect phase"
if (currentPhase == Phase.Protect)
if (isPhaseActive)
if (IsTrueForAll(AllPlayers(), CountOf(ArrayElement().selectionList) == numProtects) || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), "Tallying Votes for Protect Phase");
    #Tally votes for heroes to protect
    TallyVotes();
    selectedHeroes = [];
    //Select the numProtects most voted heroes
    while (CountOf(selectedHeroes) < numProtects) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, numProtects - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove protected heroes from the hero pool (for banning purposes)
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Remember which heroes got protected so we can add them back to the hero pool after banning
    protectedHeroes = selectedHeroes;
    #Reset the timer
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    #Reset player selection lists
    AllPlayers().selectionList = [];
    // TODO: Communicate which heroes got protected
    Wait(5, WaitBehavior.IgnoreCondition);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = numBans > 0 ? Phase.Ban : Phase.Normal;
}

disabled rule: "====BAN PHASE====" {}

rule: "Start of ban phase setup"
if (currentPhase == Phase.Ban)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    BigMessage(AllPlayers(), "Started Ban Phase");
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of ban phase"
if (currentPhase == Phase.Ban)
if (isPhaseActive)
if (IsTrueForAll(AllPlayers(), CountOf(ArrayElement().selectionList) == numBans) || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), "Tallying Votes for Ban Phase");
    #Tally votes for heroes to protect
    TallyVotes();
    selectedHeroes = [];
    //Select the numBans most voted heroes
    while (CountOf(selectedHeroes) < numBans) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, numBans - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove banned heroes from the hero pool
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Remember which heroes got banned
    bannedHeroes = selectedHeroes;
    #Reset the timer
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    #Reset player selection lists
    AllPlayers().selectionList = [];
    // TODO: Communicate which heroes got banned
    Wait(5, WaitBehavior.IgnoreCondition);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = Phase.Normal;
}

disabled rule: "====NORMAL GAMEPLAY====" {}

rule: "Prepare to enter normal gameplay"
if (currentPhase == Phase.Normal)
{
    # Add protected heroes back to the hero pool
    ModifyVariable(heroPool, Operation.AppendToArray, protectedHeroes);
    # Only allow the heroes in the pool
    SetAllowedHeroes(AllPlayers(), heroPool);
    # Disable in-game announcer during reset to Assemble Heroes
    DisableAnnouncer();
    // Skip to game in progress momentarily to allow Assemble Heroes to work
    while (!IsGameInProgress()) {
        SetMatchTime(0);
        MinWait();
    }
    GoToAssembleHeroes();
    MinWait();
    EnableAnnouncer();
}

rule: "DEBUG: Set selectedList to random assortment of heroes from heroPool"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.Interact))
if (currentPhase == Phase.Protect || currentPhase == Phase.Ban)
{
    EventPlayer().selectionList = ArraySlice(RandomizedArray(AllHeroes()),0 ,currentPhase == Phase.Protect ? numProtects : numBans);
}
