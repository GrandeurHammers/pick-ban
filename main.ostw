import "customGameSettings.lobby";
import "Credits.ostw";

globalvar Number numProtects = WorkshopSettingInteger("Protect", "Hero Protects", 1, 0, 15, 2);
globalvar Number numBans = WorkshopSettingInteger("Ban", "Hero Bans", 1, 0, 15, 0);
globalvar Team | Number losingTeam = WorkshopSettingCombo("Ban", "Extra Bans Team", 0, ["None", "Team 1", "Team 2"], 10);
globalvar Number losingTeamBans = WorkshopSettingInteger("Ban", "Extra Bans", 1, 1, 15, 11);
globalvar Number timePerPhase = WorkshopSettingInteger("General", "Time Limit Per Phase", 20, 5, 120, 9.9);
globalvar Number progressOnMaxVotes = WorkshopSettingToggle("General", "Skip Timer When All Players Have Max Selections", true, 100);
globalvar Team firstPickTeam = [RandomValueInArray([Team.Team1, Team.Team2]), Team.All, Team.Team1, Team.Team2][WorkshopSettingCombo("General", "First Pick Team", 0, ["Random (Once)", "Random (Every Phase)", "Team 1", "Team 2"], 0)];
// END CUSTOMIZATION
globalvar Hero[] protectedHeroes = [];
globalvar Hero[] bannedHeroes = [];
globalvar Hero[] heroPool = AllHeroes();
globalvar Hero | Hero[] selectedHero;
globalvar Player[] votingPlayers;
globalvar Phase currentPhase;
globalvar Boolean isPhaseActive;
globalvar Boolean endPhaseFlag;
globalvar Number selectTimeRemaining;
globalvar Team currVotingTeam;
globalvar Number[] stagesRemainingInPhase = [0, 0]; // [0] = Team 1, [1] = Team 2
globalvar Number stageStreakRemaining;
globalvar Number[] phaseHudText = []; // HUD texts to clean up at next phase transition
globalvar Number[] phaseIWText = []; // In-world texts to clean up at next phase transition
globalvar Number[] globalHudText = []; // HUD Text to clean up when mode is complete
globalvar Number[] globalIWText = []; // In-world texts to clean up when mode is complete
globalvar Number[] globalEffects = []; // Effects to clean up when mode is complete
globalvar Number i 127;

playervar Hero votedHero;
playervar Number[] personalEffects = [];

Number MaxSelectionsForPhase: [numProtects, numBans, losingTeamBans][<Number>currentPhase - 1];
Number MaxVotesPerStage: 1;
Number TeamIndex(Team team): IndexOfArrayValue([Team.Team1, Team.Team2], team);
Number STREAK_LENGTH: 2;
String PhaseName: ["Waiting", "Protect", "Ban", "Extra Ban", "Gameplay"][currentPhase];

enum Phase {
    Waiting,
    Protect,
    Ban,
    ExtraBan,
    Gameplay
}

void DisableAllHud() {
    DisableGameModeHud();
    DisableGameModeInworldUI();
    DisableHeroHud();
    DisableScoreboard();
}

void EnableAllHud() {
    EnableGameModeHud();
    EnableGameModeInworldUI();
    EnableHeroHud();
    EnableScoreboard();
}

void DisallowButtons(Button[] buttons)
{
    foreach(Button b in buttons) {
        DisallowButton(EventPlayer(), b);
    }
}

void AllowButtons(Button[] buttons)
{
    foreach(Button b in buttons) {
        AllowButton(EventPlayer(), b);
    }
}

Button[] allButtons: [Button.PrimaryFire, Button.SecondaryFire, Button.Ability1, Button.Ability2, Button.Ultimate, Button.Crouch, Button.Interact, Button.Jump, Button.Melee, Button.Reload];

globalvar Boolean inspectorEnabled = WorkshopSettingToggle("Debug", "Inspector Enabled", false, 0);
rule: "[GLOBAL SETUP] Global setup"
{
    if (!inspectorEnabled) {
        DisableInspectorRecording();
    }
    # Convert integer selection of Extras team to team constants
    losingTeam = [null, Team.Team1, Team.Team2][losingTeam];
}

rule: "[PLAYER SETUP] Force player out of initial hero select on spawn and handle conditional enable/disables"
Event.OngoingPlayer
# Shorthand for being in the ban/protect phase
if (IsWaitingForPlayers())
{
    DisableAllHud();
    EventPlayer().isInMenu = true;
    DisallowButtons(allButtons);
    ForceThrottle(EventPlayer(), 0, 0, 0, 0, 0, 0);
    SetInvisible(InvisibleTo: InvisibleTo.All);
    SetGravity(EventPlayer(), 0);
    DisableMovementCollisionWithEnvironment(IncludeFloors: false);
    DisableMovementCollisionWithPlayers();

    while(!HasSpawned(EventPlayer())) {
        ForcePlayerHero(EventPlayer(), RandomValueInArray(AllHeroes()));
        Wait(1);
        StopForcingHero(EventPlayer());
        Wait(0.25);
    }

    WaitUntil(!IsWaitingForPlayers(), 1000000);
    EnableAllHud();
    EventPlayer().isInMenu = false;
    AllowButtons(allButtons);
    StopForcingThrottle(EventPlayer());
    SetInvisible(InvisibleTo: InvisibleTo.None);
    SetGravity(EventPlayer(), 100);
    EnableMovementCollisionWithEnvironment();
    EnableMovementCollisionWithPlayers();
}

rule: "Player hero pool setup"
Event.OngoingPlayer
if (currentPhase == Phase.Gameplay)
{
    # If a hero pool has been decided, restrict the player to that pool
    SetAllowedHeroes(EventPlayer(), heroPool);
}

void StartVotingStage() "[TIMER] Start stage timer"
{
    # Start a new stage
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
}

void GoNextPhase() "[STATE MACHINE] When called, transition from current phase to the next logical phase"
{
    # First, clean up this phase
    CleanupCurrentPhase();
    Wait(0.25);
    switch(currentPhase) {
        case Phase.Waiting:
            if (numProtects > 0) {
                currentPhase = Phase.Protect;
                break;
            }
            // Note the intentional fallthrough to skip to the next phase
        case Phase.Protect:
            if (numBans > 0) {
                currentPhase = Phase.Ban;
                break;
            }
            // Note the intentional fallthrough to skip to the next phase
        case Phase.Ban:
            if (losingTeamBans > 0 && losingTeam != null) {
                currentPhase = Phase.ExtraBan;
                break;
            }
        default:
            currentPhase = Phase.Gameplay;
            return;
    }
    BigMessage(Header: <"Starting <0> Phase", PhaseName>);
    ResetVotingPhase();
    // async RefreshCursorVis();
    Wait(4);
    isPhaseActive = true;
    StartVotingStage();
}

void CleanupCurrentPhase() "[STATE MACHINE HELPER] clean up current phase"
{
    foreach (Number hud in phaseHudText) { DestroyHudText(hud); }
    foreach (Number iwt in phaseIWText) { DestroyInWorldText(iwt); }
    phaseHudText = [];
    phaseIWText = [];
    # Call individual phase hooks
    Skip(0);
    switch (currentPhase) {
        case Phase.Waiting:
            WaitPhaseCleanup();
            return;
        // TODO: Add other phase cleanup routines
    }
}

void ResetVotingPhase() "[SUB] Reset voting stage trackers" {
    # Reset trackers
    stagesRemainingInPhase = [MaxSelectionsForPhase, MaxSelectionsForPhase];
    stageStreakRemaining = 1;
    # Set the current voting team
    if (firstPickTeam == Team.All) {
        currVotingTeam = RandomValueInArray([Team.Team1, Team.Team2]);
        return;
    }
    currVotingTeam = firstPickTeam;
    AdvanceStageSelection();
}

void AdvanceStageSelection() "[SUB] Advancing stage streak logic + ending phase logic" {
    # Swap current voting team if current voting team streak has ended.
    if (stageStreakRemaining == 0) {
        currVotingTeam = OppositeTeamOf(currVotingTeam);
        stageStreakRemaining = Min(STREAK_LENGTH, stagesRemainingInPhase[TeamIndex(currVotingTeam)]);
    }
    # Check if current team is out of stages. If so, we know that the phase is over, since the current team can never have fewer stages left than the other team.
    if (stagesRemainingInPhase[TeamIndex(currVotingTeam)] == 0) {
        endPhaseFlag = true;
        return;
    }
    stageStreakRemaining -= 1;
    stagesRemainingInPhase[TeamIndex(currVotingTeam)] -= 1;
}

void TallyVotes() "[SUB] Tally votes and select most voted hero (break ties randomly)"
{
    // Where's my array reduce Sadge
    /* Iterate through everyone's selection list and accumulate votes.*/
    selectedHero = MappedArray(heroPool, 0);
    votingPlayers = AllPlayers(currVotingTeam);
    for (i = 0; CountOf(votingPlayers); 1) {
        if (IndexOfArrayValue(heroPool, votingPlayers[i].votedHero) != -1) {
            selectedHero[IndexOfArrayValue(heroPool, votingPlayers[i].votedHero)] += 1;
        }
    }
    # Choose randomly from list of most voted heroes
    i = LastOf(SortedArray(selectedHero));
    selectedHero = RandomValueInArray(FilteredArray(heroPool, selectedHero[CurrentArrayIndex()] == i));
    # Reset player selection lists
    AllPlayers().votedHero = null;
}

void SelectedHeroAction() "[SUB] Take action for selected hero"
{
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHero);
    switch (currentPhase) {
        case Phase.Ban:
        case Phase.ExtraBan:
            ModifyVariable(bannedHeroes, Operation.AppendToArray, selectedHero);
            break;
        case Phase.Protect:
            ModifyVariable(protectedHeroes, Operation.AppendToArray, selectedHero);
            break;
    }
}

rule: "[STAGE END HANDLER] When time runs out (or all players have voted), tally votes, announce result, and advance stage"
if (isPhaseActive)
# If time is up or every player has voted
if (selectTimeRemaining == 0 || (progressOnMaxVotes && IsTrueForAll(AllPlayers(), CountOf(ArrayElement().votedHero) == MaxVotesPerStage)))
{
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    BigMessage(Header: "Tallying Votes...");
    TallyVotes();
    Wait(3);
    BigMessage(AllPlayers(), <"<0>: <1>", PhaseName, HeroIconString(selectedHero)>);
    SelectedHeroAction();
    AdvanceStageSelection();
    # If the phase is over after advancing to next stage, don't start a new stage.
    AbortIf(endPhaseFlag);
    Wait(4);
    StartVotingStage();
}

rule: "[PHASE END HANDLER] When phase ends, announce phase end and transition phases"
if (currentPhase > Phase.Waiting && currentPhase < Phase.Gameplay)
if (endPhaseFlag)
{
    isPhaseActive = false;
    endPhaseFlag = false;
    # Wait to let previous Big Message finish
    Wait(3);
    BigMessage(Header: <"<0> Phase Finished", PhaseName>);
    Wait(4);
    GoNextPhase();
}

disabled rule: "====WAITING PHASE====" {}

rule: "[PHASE: WAITING] Setup HUD"
if (currentPhase == Phase.Waiting)
{
    // TODO: Create Waiting for Players IWT HUD for players
    CreateInWorldText(
        VisibleTo:          visibleIf(LocalPlayer().isInMenu),
        Header:             <"<0>/<1> <2> <3>",
                                CountOf(FilteredArray(AllPlayers(), HasSpawned(ArrayElement()))),
                                NumberOfPlayers(),
                                @"Players",
                                @"Spawned"
                            >,
        Position:           OnScreenText.WorldRender(camPos, camFacing, 0, 1.3),
        Clipping:           Clipping.DoNotClip,
        Scale:              3,
        Reevaluation:       InworldTextRev.VisibleToPositionAndString,
        Spectators:         Spectators.VisibleNever
    );
    ModifyVariable(phaseIWText, Operation.AppendToArray, LastTextID());
    CreateHudText(
        VisibleTo: null,
        Header: <"<0>/<1> <2> <3>",
            CountOf(FilteredArray(AllPlayers(), HasSpawned(ArrayElement()))),
            NumberOfPlayers(),
            @"Players",
            @"Spawned"
        >,
        Location: Location.Top,
        SortOrder: 1,
        HeaderColor: Color.Yellow,
        Spectators: Spectators.VisibleAlways
    );
    ModifyVariable(phaseHudText, Operation.AppendToArray, LastTextID());
}

rule: "[PHASE: WAITING] Start mode"
if (IsWaitingForPlayers())
if (currentPhase == Phase.Waiting)
# Ensure at least one player is playing
if (NumberOfPlayers() > 0)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    BigMessage(AllPlayers(), "Starting in 15 seconds...");
    Wait(5);
    BigMessage(AllPlayers(), "Starting in 10 seconds...");
    Wait(5);
    BigMessage(AllPlayers(), "Starting in 5 seconds...");
    Wait(5);
    GoNextPhase();
}

void WaitPhaseCleanup() "[PHASE: WAITING] clean up"
{
    # TODO: Any specific waiting phase cleanup
}

// rule: "Handle conditional player enable/disables"
// Event.OngoingPlayer
// if (currentPhase != Phase.Normal)
// if (HasSpawned())
// {
//     ForceThrottle(EventPlayer(), 0, 0, 0, 0, 0, 0);
//     SetInvisible(InvisibleTo: InvisibleTo.All);
//     SetGravity(EventPlayer(), 0);
//     DisableMovementCollisionWithEnvironment(IncludeFloors: false);
//     DisableMovementCollisionWithPlayers();
//     DisableMessages();
//     EventPlayer().isInMenu = true;
//     DisableGameModeHud();
//     DisableGameModeInworldUI();
//     DisallowButtons(allButtons);

//     WaitUntil(currentPhase == Phase.Normal && IsAssemblingHeroes(), 1000000);
//     EventPlayer().isInMenu = false;
//     Wait(0.25);

//     StopForcingThrottle(EventPlayer());
//     SetInvisible(InvisibleTo: InvisibleTo.None);
//     SetGravity(EventPlayer(), 100);
//     EnableMovementCollisionWithEnvironment();
//     EnableMovementCollisionWithPlayers();
//     EnableMessages();
//     EnableGameModeHud();
//     EnableGameModeInworldUI();
//     AllowButtons(allButtons);
// }

disabled rule: "====PROTECT PHASE====" {}



disabled rule: "====BAN PHASE====" {}

disabled rule: "====EXTRA BAN PHASE====" {}

disabled rule: "====NORMAL GAMEPLAY====" {}

void FinalCleanup() "[SUB] Perform cleanup of phase-agnostic elements"
{
    DestroyAllProgressBarHudText();
    DestroyAllProgressBarInWorldText();
    foreach(Number text in globalHudText) { DestroyHudText(text); }
    foreach(Number text in globalIWText) { DestroyInWorldText(text); }
    foreach(Number eff in globalEffects) { DestroyEffect(eff); }
}

rule: "Prepare to enter normal gameplay"
if (currentPhase == Phase.Gameplay)
{
    # Add protected heroes back to the hero pool
    ModifyVariable(heroPool, Operation.AppendToArray, protectedHeroes);
    # Only allow the heroes in the pool
    SetAllowedHeroes(AllPlayers(), heroPool);
    # Clean up all texts and effects
    FinalCleanup();
    StartGameMode();
    Wait(2);
    destroyMenu();
}

import "interface/HeroSelectAnywhere.del";
import "coreDebug.ostw";
import "interface/miscSetup.del";
