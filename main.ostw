import "customGameSettings.lobby";

globalvar define numProtects;
globalvar define numBans;
globalvar define timePerPhase;
// END CUSTOMIZATION
globalvar Phase currentPhase;
globalvar define isPhaseActive;
globalvar define selectTimeRemaining;
globalvar define heroPool;
globalvar define protectedHeroes;
globalvar define bannedHeroes;
globalvar define resultsTally;
globalvar define selectedHeroes;
globalvar define textsToDestroy;
globalvar define i 127;

playervar define selectionList;
playervar define textToDestroy;

enum Phase {
    Waiting,
    Protect = 1,
    Ban = 2,
    Normal = 3
} 

rule: "Customization Workshop Settings" 
{
    numProtects = WorkshopSettingInteger("Pick/Ban", "Hero Protects", 1, 0, 15, 1);
    numBans = WorkshopSettingInteger("Pick/Ban", "Hero Bans", 1, 0, 15, 0);
    timePerPhase = WorkshopSettingInteger("Pick/Ban", "Time Limit Per Phase", 20, 5, 120, 2);
}

void TallyVotes() "[SUB] Count up number of votes for each hero"
{
    resultsTally = [];
    for (i = 0; CountOf(AllHeroes()); 1) {
        resultsTally[i] = CountOf(FilteredArray(AllPlayers(), ArrayContains(ArrayElement().selectionList, AllHeroes()[i])));
    }
}

rule: "Global setup"
if (IsWaitingForPlayers() == false)
if (currentPhase == Phase.Waiting)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())) && CountOf(AllPlayers()) > 0)
{

    # Initialize the hero pool
    heroPool = AllHeroes();
    # Set the current phase
    if (numProtects > 0) {
        currentPhase = Phase.Protect;
    } else if (numBans > 0) {
        currentPhase = Phase.Ban;
    } else {
        currentPhase = Phase.Normal;
    }
    AbortIf(currentPhase == Phase.Normal);
    # Prevent normal game stuff from interfering
    DisableAnnouncer();
    DisableMessages(AllPlayers());
    # Create some universal HUDs
    CreateProgressBarHudText(
        VisibleTo: selectTimeRemaining > 0 ? AllPlayers() : null,
        Value: selectTimeRemaining / timePerPhase * 100,
        Text: <@"Time Remaining: <0> sec", RoundToInteger(selectTimeRemaining, Rounding.Up)>,
        Location: Location.Top,
        SortOrder: 5,
        ProgressBarColor: CustomColor(
            Red:   255,
            Green: Min(255, 255*(selectTimeRemaining*2/timePerPhase)^2),
            Blue:  Min(255, 255*(selectTimeRemaining*2/timePerPhase)^2),
            Alpha: 255
        ),
        TextColor: Color.White,
        Reevaluation: ProgressBarEvaluation.VisibleToValuesAndColor
    );
    textsToDestroy = [LastTextID()];
    CreateHudText(
        VisibleTo: selectTimeRemaining > 0 ? AllPlayers() : null,
        Header: <@"Selected Heroes">,
        Location: Location.Right,
        SortOrder: -100,
        HeaderColor: Color.Aqua,
        Reevaluation: HudTextRev.VisibleTo,
        Spectators: Spectators.VisibleNever
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
}

rule: "For protect and ban phases, skip Assembling Heroes and freeze time"
if (IsAssemblingHeroes())
if (currentPhase != Phase.Normal)
{
    SetMatchTime(0);
    WaitUntil(Not(IsAssemblingHeroes()), 1000000);
    PauseMatchTime();
    WaitUntil(currentPhase == Phase.Normal, 1000000);
    UnpauseMatchTime();
}

rule: "Player setup"
Event.OngoingPlayer
{
    # Initialize player selection list
    EventPlayer().selectionList = [];
    # If a hero pool has been decided, restrict the player to that pool
    if (currentPhase == Phase.Normal) {
        SetAllowedHeroes(EventPlayer(), heroPool);
    }
    textToDestroy = [];
    for (i = 0; Max(numProtects, numBans) / 4; 1) {
        CreateHudText(
            VisibleTo:      CountOf(selectionList) > 4*EvaluateOnce(i) ? EventPlayer() : null,
            Header:         <"<0><1><2><3>", 
                                HeroIconString(selectionList[4*EvaluateOnce(i)+0]),
                                HeroIconString(selectionList[4*EvaluateOnce(i)+1]),
                                HeroIconString(selectionList[4*EvaluateOnce(i)+2]),
                                HeroIconString(selectionList[4*EvaluateOnce(i)+3])
                            >,
            Location: Location.Right,
            SortOrder: -99 + 4*i,
            Reevaluation: HudTextRev.VisibleToAndString,
            Spectators: Spectators.VisibleNever
        );
        ModifyVariable(textToDestroy, Operation.AppendToArray, LastTextID());
    }
}

rule: "Handle conditional player enable/disables"
Event.OngoingPlayer
if (currentPhase == Phase.Protect || currentPhase == Phase.Ban)
{
    StartForcingPlayerPosition(EventPlayer(), Vector(0,50,0), true);
    SetInvisible(InvisibleTo: InvisibleTo.All);
    DisableMovementCollisionWithEnvironment();
    DisableMovementCollisionWithPlayers();
    DisableMessages();
    EventPlayer().isInMenu = true;
    DisableGameModeHud();
    DisableGameModeInworldUI();

    WaitUntil(currentPhase != Phase.Protect && currentPhase != Phase.Ban, 1000000);
    Wait(1);

    StopForcingPlayerPosition(EventPlayer());
    SetInvisible(InvisibleTo: InvisibleTo.None);
    EnableMovementCollisionWithEnvironment();
    EnableMovementCollisionWithPlayers();
    EnableMessages();
    EventPlayer().isInMenu = false;
    EnableGameModeHud();
    EnableGameModeInworldUI();

    for (define j = 0; CountOf(textToDestroy); 1) {
        DestroyHudText(textToDestroy[j]);
    }
}

disabled rule: "====PROTECT PHASE====" {}

rule: "Start of protect phase setup"
if (currentPhase == Phase.Protect)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    # Be sure everyone has the menu open for Protect phase
    AllPlayers().isInMenu = true;
    BigMessage(AllPlayers(), <@"Started Protect Phase">);
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of protect phase"
if (currentPhase == Phase.Protect)
if (isPhaseActive)
if (IsTrueForAll(AllPlayers(), CountOf(ArrayElement().selectionList) == numProtects) || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), <@"Protect Phase Finished">);
    #Tally votes for heroes to protect
    TallyVotes();
    selectedHeroes = [];
    //Select the numProtects most voted heroes
    while (CountOf(selectedHeroes) < numProtects) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, numProtects - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove protected heroes from the hero pool (for banning purposes)
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Remember which heroes got protected so we can add them back to the hero pool after banning
    protectedHeroes = selectedHeroes;
    #Reset the timer
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    #Reset player selection lists
    AllPlayers().selectionList = [];
    # Show which heroes have been protected
    CreateHudText(
        VisibleTo: AllPlayers(),
        Header: @"Protect:",
        Location: Location.Left,
        SortOrder: 0,
        HeaderColor: Color.Yellow,
        Reevaluation: HudTextRev.VisibleTo
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    for (i = 0; CountOf(protectedHeroes) / 4; 1) {
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: <"<0><1><2><3>",
                EvaluateOnce(HeroIconString(protectedHeroes[4*i])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+1])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+2])),
                EvaluateOnce(HeroIconString(protectedHeroes[4*i+3]))
            >,
            Location: Location.Left,
            SortOrder: i+1,
            HeaderColor: Color.White,
            Reevaluation: HudTextRev.VisibleTo
        );
        ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    }
    Wait(5);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = numBans > 0 ? Phase.Ban : Phase.Normal;
}

disabled rule: "====BAN PHASE====" {}

rule: "Start of ban phase setup"
if (currentPhase == Phase.Ban)
if (isPhaseActive == false)
# Wait for everyone to spawn in
if (IsTrueForAll(AllPlayers(), HasSpawned(ArrayElement())))
{
    # Be sure everyone has the menu open for Protect phase
    AllPlayers().isInMenu = true;
    BigMessage(AllPlayers(), <@"Started Ban Phase">);
    # Begin timing
    selectTimeRemaining = timePerPhase;
    ChaseVariableAtRate(selectTimeRemaining, 0, 1, RateChaseReevaluation.None);
    # Set phase active flag
    isPhaseActive = true;
}

rule: "End of ban phase"
if (currentPhase == Phase.Ban)
if (isPhaseActive)
if (IsTrueForAll(AllPlayers(), CountOf(ArrayElement().selectionList) == numBans) || selectTimeRemaining == 0)
{
    BigMessage(AllPlayers(), <@"Finished Ban Phase">);
    #Tally votes for heroes to protect
    TallyVotes();
    selectedHeroes = [];
    //Select the numBans most voted heroes
    while (CountOf(selectedHeroes) < numBans) {
        # Get largest number of votes
        i = LastOf(SortedArray(resultsTally));
        # Add as many heroes as permissible which have that number of votes
        ModifyVariable(selectedHeroes, Operation.AppendToArray, ArraySlice(RandomizedArray(FilteredArray(AllHeroes(), resultsTally[CurrentArrayIndex()] == i)), 0, numBans - CountOf(selectedHeroes)));
        # Invalidate current largest number of votes
        resultsTally = MappedArray(resultsTally, (ArrayElement() == i ? -1 : 1) * ArrayElement());
    }
    #Remove banned heroes from the hero pool
    ModifyVariable(heroPool, Operation.RemoveFromArrayByValue, selectedHeroes);
    #Remember which heroes got banned
    bannedHeroes = selectedHeroes;
    #Reset the timer
    StopChasingVariable(selectTimeRemaining);
    selectTimeRemaining = 0;
    #Reset player selection lists
    AllPlayers().selectionList = [];
    # Spacer HUD
    CreateHudText(
        VisibleTo: AllPlayers(),
        Text: " \n",
        Location: Location.Left,
        SortOrder: numProtects+0.5,
        Reevaluation: HudTextRev.VisibleTo
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    CreateHudText(
        VisibleTo: AllPlayers(),
        Header: @"Ban:",
        Location: Location.Left,
        SortOrder: numProtects+1,
        HeaderColor: Color.Red,
        Reevaluation: HudTextRev.VisibleTo
    );
    ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    for (i = 0; CountOf(bannedHeroes) / 4; 1) {
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: <"<0><1><2><3>",
                EvaluateOnce(HeroIconString(bannedHeroes[4*i])),
                EvaluateOnce(HeroIconString(bannedHeroes[4*i+1])),
                EvaluateOnce(HeroIconString(bannedHeroes[4*i+2])),
                EvaluateOnce(HeroIconString(bannedHeroes[4*i+3]))
            >,
            Location: Location.Left,
            SortOrder: numProtects+i+2,
            HeaderColor: Color.White,
            Reevaluation: HudTextRev.VisibleTo
        );
        ModifyVariable(textsToDestroy, Operation.AppendToArray, LastTextID());
    }
    Wait(5);
    #phase no longer running
    isPhaseActive = false;
    #Move on to next phase
    currentPhase = Phase.Normal;
}

disabled rule: "====NORMAL GAMEPLAY====" {}

rule: "Prepare to enter normal gameplay"
if (currentPhase == Phase.Normal)
{
    # Add protected heroes back to the hero pool
    ModifyVariable(heroPool, Operation.AppendToArray, protectedHeroes);
    # Only allow the heroes in the pool
    SetAllowedHeroes(AllPlayers(), heroPool);
    # Disable in-game announcer during reset to Assemble Heroes
    DisableAnnouncer();
    # Disable messages during reset to Assemble Heroes
    DisableMessages(AllPlayers());
    // Skip to game in progress momentarily to allow Assemble Heroes to work
    while (!IsGameInProgress()) {
        SetMatchTime(0);
        MinWait();
    }
    Wait(0.25);
    EnableAnnouncer();
    EnableMessages(AllPlayers());
    GoToAssembleHeroes();
    WaitUntil(IsGameInProgress(), 9999);
    for (i = 0; CountOf(textsToDestroy); 1) {
        DestroyHudText(textsToDestroy[i]);
    }
    textsToDestroy = [];
}

disabled rule: "DEBUG: Add current hero to selectionList"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.Interact))
if (currentPhase == Phase.Protect || currentPhase == Phase.Ban)
{
    ModifyVariable(EventPlayer().selectionList, Operation.AppendToArray, HeroOf(EventPlayer()));
    MinWait();
    SmallMessage(EventPlayer(), <"Selected Hero: <0>", HeroIconString(LastOf(EventPlayer().selectionList))>);
}

import "PlayerInterface.del";
