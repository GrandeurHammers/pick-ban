import "ScreenToWorld.del";
import "ServerLoad.del";
import "ClickArea.del";

import "MapData.del";

import "main.ostw";

globalvar define menuPos = ArrayContains(maps, CurrentMap()) ? mapData[IndexOfArrayValue(maps, CurrentMap())][0] : Vector(0, 150, 0);
globalvar define menuFacing = ArrayContains(maps, CurrentMap()) ? mapData[IndexOfArrayValue(maps, CurrentMap())][1] : Forward();
globalvar define menuTitle = "Protect Phase - 10";
globalvar define[] playersInMenu = [];
define AllHeroesOrdered: Append(Append(AllTankHeroes(), AllDamageHeroes()), AllSupportHeroes());

define getNthHeroIcon(define n): n < CountOf(AllHeroes()) ? ArrayContains(heroPool, AllHeroesOrdered[n]) ? HeroIconString(AllHeroesOrdered[n]) : 
    ArrayContains(protectedHeroes, AllHeroesOrdered[n]) ? IconString(Icon.Checkmark) : IconString(Icon.No) : IconString(Icon.RingThin);
globalvar ClickArea[] menuButtons = [];
globalvar define[] menuTexts = [];

rule: "[PlayerInterface.del] Initialize menu"
{
    CreateEffect(
        VisibleTo:          playersInMenu,
        Type:               Effect.Orb,
        Color:              Color.Black,
        Position:           menuPos + -0.33 * menuFacing,
        Radius:             1,
        Reevaluation:       EffectRev.VisibleTo
    );
    CreateInWorldText(
        VisibleTo:          playersInMenu,
        Header:             selectTimeRemaining > 0 ?
            <@"<0> Phase", currentPhase == Phase.Protect ? @"Protect" : @"Ban"> : 
            "",
        Position:           ScreenToWorld(menuPos, menuFacing, 0, 1.5),
        Scale:              3,
        Clipping:           Clipping.DoNotClip,
        Reevaluation:       InworldTextRev.VisibleToAndString,
        TextColor:          Color.White
    );
    ModifyVariable(menuTexts, Operation.AppendToArray, LastTextID());
    for (i = 0; i < CountOf(AllHeroesOrdered) / 8; i++) {
        CreateInWorldText(
            VisibleTo:          playersInMenu,
            Header:             <"<0>  <1>  <2>  <3>", 
                                    getNthHeroIcon(8*EvaluateOnce(i)+0), 
                                    getNthHeroIcon(8*EvaluateOnce(i)+1), 
                                    getNthHeroIcon(8*EvaluateOnce(i)+2), 
                                    getNthHeroIcon(8*EvaluateOnce(i)+3)
                                >,
            Position:           ScreenToWorld(menuPos, menuFacing, -0.8, 0.8 - 0.5*i),
            Scale:              3.5,
            Clipping:           Clipping.DoNotClip,
            Reevaluation:       InworldTextRev.VisibleToAndString,
            TextColor:          Color.White
        );
        ModifyVariable(menuTexts, Operation.AppendToArray, LastTextID());
        CreateInWorldText(
            VisibleTo:          playersInMenu,
            Header:             <"<0>  <1>  <2>  <3>", 
                                    getNthHeroIcon(8*EvaluateOnce(i)+4), 
                                    getNthHeroIcon(8*EvaluateOnce(i)+5), 
                                    getNthHeroIcon(8*EvaluateOnce(i)+6), 
                                    getNthHeroIcon(8*EvaluateOnce(i)+7)
                                >,
            Position:           ScreenToWorld(menuPos, menuFacing, 0.8, 0.8 - 0.5*i),
            Scale:              3.5,
            Clipping:           Clipping.DoNotClip,
            Reevaluation:       InworldTextRev.VisibleToAndString,
            TextColor:          Color.White
        );
        ModifyVariable(menuTexts, Operation.AppendToArray, LastTextID());
    }

    for (i = 0; i < CountOf(AllHeroesOrdered); i++) {
        ModifyVariable(menuButtons, Operation.AppendToArray, new ClickArea(-1.4 + 0.4*(i%8), 0.85 - 0.5*Quotient(i, 8), 0.33, 0.33, AllHeroesOrdered[i]));
    }

    CreateInWorldText(
        VisibleTo:          playersInMenu,
        Header:             "Clear selection",
        Position:           ScreenToWorld(menuPos, menuFacing, 0, -1.2),
        Scale:              2,
        Clipping:           Clipping.DoNotClip,
        Reevaluation:       InworldTextRev.VisibleToAndString,
        TextColor:          Color.Yellow
    );
    ModifyVariable(menuTexts, Operation.AppendToArray, LastTextID());
    ModifyVariable(menuButtons, Operation.AppendToArray, new ClickArea(0, -1.2, 0.9, 0.15, "clear"));
}

void destroyMenu()
{
    foreach(define text in menuTexts) DestroyInWorldText(text);
}

playervar define isInMenu;
playervar define menuOriginalFacing;
playervar define[] cursorTexts;
playervar ClickArea hoveredButton;
define cursorSens: 1.5;
define cursorXRaw: cursorSens/5 * AngleDifference(HorizontalAngleFromDirection(FacingDirectionOf()), HorizontalAngleFromDirection(menuOriginalFacing));
define cursorYRaw: cursorSens/5 * AngleDifference(VerticalAngleFromDirection(FacingDirectionOf()), VerticalAngleFromDirection(menuOriginalFacing));
define menuXMin: -2.5;
define menuXMax: 2.5;
define menuYMin: -1.5;
define menuYMax: 1.25;
define cursorX: Max(menuXMin, Min(menuXMax, cursorXRaw));
define cursorY: Max(menuYMin, Min(menuYMax, cursorYRaw));
rule: "[PlayerInterface.del] Update hovered button"
Event.OngoingPlayer
if(isInMenu)
{
    define foundButton = false;
    for(i = 0; i < CountOf(menuButtons); i++) {
        if (menuButtons[i].isHovered(cursorX, cursorY)) {
            hoveredButton = menuButtons[i];
            foundButton = true;
            break;
        }
    }
    if(!foundButton) hoveredButton = null;
    MinWait();
    LoopIfConditionIsTrue();
}


void DisallowButtons(Button[] buttons)
{
    foreach(Button b in buttons) {
        DisallowButton(EventPlayer(), b);
    }
}

void AllowButtons(Button[] buttons)
{
    foreach(Button b in buttons) {
        AllowButton(EventPlayer(), b);
    }
}

define allButtons: [Button.PrimaryFire, Button.SecondaryFire, Button.Ability1, Button.Ability2, Button.Ultimate, Button.Crouch, Button.Interact, Button.Jump, Button.Melee, Button.Reload];


disabled rule: "[PlayerInterface.del] Force menu (debug)"
Event.OngoingPlayer
if(HasSpawned())
{
    isInMenu = true;
}

rule: "[PlayerInterface.del] Menu open/close"
Event.OngoingPlayer
if(isInMenu)
{
    StartCamera(EyePosition: menuPos, LookAtPosition: menuPos + menuFacing);
    ModifyVariable(playersInMenu, Operation.AppendToArray, EventPlayer());
    DisableHeroHud(EventPlayer());
    menuOriginalFacing = FacingDirectionOf();
    DisallowButtons(allButtons);
    SetAimSpeed(EventPlayer(), 50);
    makeCursor();

    WaitUntil(!isInMenu, 9999);
    ModifyVariable(playersInMenu, Operation.RemoveFromArrayByValue, EventPlayer());
    EnableHeroHud(EventPlayer());
    AllowButtons(allButtons);
    SetAimSpeed(EventPlayer(), 100);
    destroyCursor();
    StopCamera(EventPlayer());
}

rule: "[PlayerInterface.del] Teleport out of spawn while in menu (except Control)"
Event.OngoingPlayer
if(isInMenu)
if(IsInSpawnRoom())
if(CurrentGameMode() != GameMode.Control)
{
    Teleport(EventPlayer(), Vector(0, 250, 0));
}

void makeCursor()
{
    CreateInWorldText(
        VisibleTo:          globalCursors ? playersInMenu : EventPlayer(),
        Header:             "▲",
        Position:           UpdateEveryFrame(ScreenToWorld(menuPos, menuFacing, cursorX, cursorY)),
        Scale:              3,
        Clipping:           Clipping.DoNotClip,
        Reevaluation:       InworldTextRev.VisibleToAndPosition,
        TextColor:          TeamOf() == Team.Team1 ? Color.Team1 : Color.Team2
    );
    ModifyVariable(cursorTexts, Operation.AppendToArray, LastTextID());
    CreateInWorldText(
        VisibleTo:          globalCursors ? playersInMenu : EventPlayer(),
        Header:             EventPlayer(),
        Position:           UpdateEveryFrame(ScreenToWorld(menuPos, menuFacing, cursorX, cursorY-0.1)),
        Scale:              1.25,
        Clipping:           Clipping.DoNotClip,
        Reevaluation:       InworldTextRev.VisibleToAndPosition,
        TextColor:          Color.White
    );
    ModifyVariable(cursorTexts, Operation.AppendToArray, LastTextID());

    CreateInWorldText(
        VisibleTo:          EventPlayer(),
        Header:             "┌",
        Position:           UpdateEveryFrame(ScreenToWorld(menuPos, menuFacing, hoveredButton.centerX - hoveredButton.sizeX/2, hoveredButton.centerY + hoveredButton.sizeY/2)),
        Scale:              2.5,
        Clipping:           Clipping.DoNotClip,
        Reevaluation:       InworldTextRev.VisibleToPositionAndColor,
        TextColor:          UpdateEveryFrame(
                                hoveredButton == null || selectTimeRemaining == 0 ? 
                                    CustomColor(0,0,0,0) :
                                    ArrayContains(heroPool, hoveredButton.clickID) ?
                                        ArrayContains(selectionList, hoveredButton.clickID) ? Color.Red :
                                        Color.Green :
                                    Color.White
                            )
    );
    ModifyVariable(cursorTexts, Operation.AppendToArray, LastTextID());
    CreateInWorldText(
        VisibleTo:          EventPlayer(),
        Header:             "┐",
        Position:           UpdateEveryFrame(ScreenToWorld(menuPos, menuFacing, hoveredButton.centerX + hoveredButton.sizeX/2, hoveredButton.centerY + hoveredButton.sizeY/2)),
        Scale:              2.5,
        Clipping:           Clipping.DoNotClip,
        Reevaluation:       InworldTextRev.VisibleToPositionAndColor,
        TextColor:          UpdateEveryFrame(
                                hoveredButton == null || selectTimeRemaining == 0 ? 
                                    CustomColor(0,0,0,0) :
                                    ArrayContains(heroPool, hoveredButton.clickID) ?
                                        ArrayContains(selectionList, hoveredButton.clickID) ? Color.Red :
                                        Color.Green :
                                    Color.White
                            )
    );
    ModifyVariable(cursorTexts, Operation.AppendToArray, LastTextID());
    CreateInWorldText(
        VisibleTo:          EventPlayer(),
        Header:             "└",
        Position:           UpdateEveryFrame(ScreenToWorld(menuPos, menuFacing, hoveredButton.centerX - hoveredButton.sizeX/2, hoveredButton.centerY - hoveredButton.sizeY/2)),
        Scale:              2.5,
        Clipping:           Clipping.DoNotClip,
        Reevaluation:       InworldTextRev.VisibleToPositionAndColor,
        TextColor:          UpdateEveryFrame(
                                hoveredButton == null || selectTimeRemaining == 0 ? 
                                    CustomColor(0,0,0,0) :
                                    ArrayContains(heroPool, hoveredButton.clickID) ?
                                        ArrayContains(selectionList, hoveredButton.clickID) ? Color.Red :
                                        Color.Green :
                                    Color.White
                            )
    );
    ModifyVariable(cursorTexts, Operation.AppendToArray, LastTextID());
    CreateInWorldText(
        VisibleTo:          EventPlayer(),
        Header:             "┘",
        Position:           UpdateEveryFrame(ScreenToWorld(menuPos, menuFacing, hoveredButton.centerX + hoveredButton.sizeX/2, hoveredButton.centerY - hoveredButton.sizeY/2)),
        Scale:              2.5,
        Clipping:           Clipping.DoNotClip,
        Reevaluation:       InworldTextRev.VisibleToPositionAndColor,
        TextColor:          UpdateEveryFrame(
                                hoveredButton == null || selectTimeRemaining == 0 ? 
                                    CustomColor(0,0,0,0) :
                                    ArrayContains(heroPool, hoveredButton.clickID) ?
                                        ArrayContains(selectionList, hoveredButton.clickID) ? Color.Red :
                                        Color.Green :
                                    Color.White
                            )
    );
    ModifyVariable(cursorTexts, Operation.AppendToArray, LastTextID());
}

void destroyCursor()
{
    foreach(define text in cursorTexts) DestroyInWorldText(text);
}

rule: "[PlayerInterface.del] Menu outer bounds"
Event.OngoingPlayer
if(isInMenu)
if(cursorXRaw/2 > menuXMax || cursorXRaw/2 < menuXMin || cursorYRaw/2 > menuYMax || cursorYRaw/2 < menuYMin )
{
    SetFacing(EventPlayer(), DirectionFromAngles(HorizontalAngleFromDirection(menuOriginalFacing) - 5/cursorSens*cursorX, VerticalAngleFromDirection(menuOriginalFacing) - 5/cursorSens*cursorY));
}

rule: "[PlayerInterface.del] Click logic"
Event.OngoingPlayer
if(isInMenu)
if(IsButtonHeld(EventPlayer(), Button.PrimaryFire))
# If in a valid phase
if (selectTimeRemaining > 0 && (currentPhase == Phase.Ban || currentPhase == Phase.Protect))
{
    if(hoveredButton != null) {
        define clickedID = hoveredButton.clickID;
        if(ArrayContains(AllHeroes(), clickedID)) {
            if(ArrayContains(heroPool, clickedID)) {
                if(ArrayContains(selectionList, clickedID)) {
                    ModifyVariable(selectionList, Operation.RemoveFromArrayByValue, clickedID);
                    PlayEffect(EventPlayer(), PlayEffect.ExplosionSound, Color.White, menuPos, 50);
                }
                else {
                    ModifyVariable(selectionList, Operation.AppendToArray, clickedID);
                    PlayEffect(EventPlayer(), PlayEffect.BuffExplosionSound, Color.White, menuPos, 50);
                }
            }
            else {
                PlayEffect(EventPlayer(), PlayEffect.ExplosionSound, Color.White, menuPos, 50);
            }
        }
        else if(clickedID == "clear") {
            selectionList = [];
            PlayEffect(EventPlayer(), PlayEffect.RingExplosionSound, Color.White, menuPos, 50);
        }
    }
}